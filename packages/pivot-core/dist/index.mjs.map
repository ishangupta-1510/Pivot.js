{"version":3,"sources":["../src/aggregator.ts","../src/data-filter.ts","../src/data-transformer.ts","../src/data-validator.ts","../src/pivot-engine.ts"],"names":["cell"],"mappings":"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","file":"index.mjs","sourcesContent":["import { DataRow, DataValue } from './types/data.types';\nimport { AggregationType } from './types/pivot.types';\n\nexport class DataAggregator {\n  static aggregate(data: DataRow[], field: string, aggregationType: AggregationType): DataValue {\n    if (!data || data.length === 0) return null;\n\n    const values = data\n      .map(row => row[field])\n      .filter(value => value !== null && value !== undefined);\n\n    if (values.length === 0) return null;\n\n    switch (aggregationType) {\n      case 'sum':\n        return this.sum(values);\n      case 'count':\n        return values.length;\n      case 'countDistinct':\n        return new Set(values).size;\n      case 'average':\n        return this.average(values);\n      case 'min':\n        return this.min(values);\n      case 'max':\n        return this.max(values);\n      case 'median':\n        return this.median(values);\n      case 'mode':\n        return this.mode(values);\n      default:\n        throw new Error(`Unsupported aggregation type: ${aggregationType}`);\n    }\n  }\n\n  static groupBy(data: DataRow[], fields: string[]): Map<string, DataRow[]> {\n    const groups = new Map<string, DataRow[]>();\n\n    data.forEach(row => {\n      const key = fields.map(field => String(row[field] ?? '')).join('|');\n      \n      if (!groups.has(key)) {\n        groups.set(key, []);\n      }\n      groups.get(key)!.push(row);\n    });\n\n    return groups;\n  }\n\n  static pivot(data: DataRow[], rowFields: string[], columnFields: string[], valueField: string, aggregationType: AggregationType): any {\n    const result: any = {};\n\n    // Group by row fields\n    const rowGroups = this.groupBy(data, rowFields);\n\n    rowGroups.forEach((rowData, rowKey) => {\n      result[rowKey] = {};\n\n      // Group by column fields within each row group\n      const columnGroups = this.groupBy(rowData, columnFields);\n\n      columnGroups.forEach((cellData, columnKey) => {\n        result[rowKey][columnKey] = this.aggregate(cellData, valueField, aggregationType);\n      });\n    });\n\n    return result;\n  }\n\n  private static sum(values: DataValue[]): number {\n    return values.reduce<number>((acc, value) => {\n      const num = this.toNumber(value);\n      return acc + (isNaN(num) ? 0 : num);\n    }, 0);\n  }\n\n  private static average(values: DataValue[]): number {\n    const numericValues = values.map(this.toNumber).filter(n => !isNaN(n));\n    if (numericValues.length === 0) return 0;\n    return numericValues.reduce((a, b) => a + b, 0) / numericValues.length;\n  }\n\n  private static min(values: DataValue[]): DataValue {\n    const numericValues = values.map(this.toNumber).filter(n => !isNaN(n));\n    if (numericValues.length === 0) return null;\n    return Math.min(...numericValues);\n  }\n\n  private static max(values: DataValue[]): DataValue {\n    const numericValues = values.map(this.toNumber).filter(n => !isNaN(n));\n    if (numericValues.length === 0) return null;\n    return Math.max(...numericValues);\n  }\n\n  private static median(values: DataValue[]): number {\n    const numericValues = values.map(this.toNumber).filter(n => !isNaN(n)).sort((a, b) => a - b);\n    if (numericValues.length === 0) return 0;\n    \n    const mid = Math.floor(numericValues.length / 2);\n    return numericValues.length % 2 === 0\n      ? (numericValues[mid - 1] + numericValues[mid]) / 2\n      : numericValues[mid];\n  }\n\n  private static mode(values: DataValue[]): DataValue {\n    const frequency = new Map<DataValue, number>();\n    let maxCount = 0;\n    let mode: DataValue = null;\n\n    values.forEach(value => {\n      const count = (frequency.get(value) || 0) + 1;\n      frequency.set(value, count);\n      \n      if (count > maxCount) {\n        maxCount = count;\n        mode = value;\n      }\n    });\n\n    return mode;\n  }\n\n  private static toNumber(value: DataValue): number {\n    if (typeof value === 'number') return value;\n    if (typeof value === 'string') {\n      const parsed = parseFloat(value);\n      return isNaN(parsed) ? NaN : parsed;\n    }\n    if (value instanceof Date) return value.getTime();\n    return NaN;\n  }\n}","import { DataRow, DataValue, DataFilter, DataSort } from './types/data.types';\n\nexport class DataFilterService {\n  static filter(data: DataRow[], filters: DataFilter[]): DataRow[] {\n    if (!filters || filters.length === 0) return data;\n\n    return data.filter(row => \n      filters.every(filter => this.matchesFilter(row, filter))\n    );\n  }\n\n  static sort(data: DataRow[], sorts: DataSort[]): DataRow[] {\n    if (!sorts || sorts.length === 0) return data;\n\n    return [...data].sort((a, b) => {\n      for (const sort of sorts) {\n        const comparison = this.compareValues(a[sort.field], b[sort.field]);\n        if (comparison !== 0) {\n          return sort.direction === 'desc' ? -comparison : comparison;\n        }\n      }\n      return 0;\n    });\n  }\n\n  static search(data: DataRow[], searchTerm: string, fields?: string[]): DataRow[] {\n    if (!searchTerm.trim()) return data;\n\n    const term = searchTerm.toLowerCase();\n    const searchFields = fields || Object.keys(data[0] || {});\n\n    return data.filter(row =>\n      searchFields.some(field => {\n        const value = row[field];\n        if (value === null || value === undefined) return false;\n        return String(value).toLowerCase().includes(term);\n      })\n    );\n  }\n\n  private static matchesFilter(row: DataRow, filter: DataFilter): boolean {\n    const value = row[filter.field];\n    const filterValue = filter.value;\n\n    switch (filter.operator) {\n      case 'eq':\n        return this.compareValues(value, filterValue as DataValue) === 0;\n      case 'ne':\n        return this.compareValues(value, filterValue as DataValue) !== 0;\n      case 'gt':\n        return this.compareValues(value, filterValue as DataValue) > 0;\n      case 'gte':\n        return this.compareValues(value, filterValue as DataValue) >= 0;\n      case 'lt':\n        return this.compareValues(value, filterValue as DataValue) < 0;\n      case 'lte':\n        return this.compareValues(value, filterValue as DataValue) <= 0;\n      case 'contains':\n        return String(value || '').toLowerCase().includes(String(filterValue || '').toLowerCase());\n      case 'startsWith':\n        return String(value || '').toLowerCase().startsWith(String(filterValue || '').toLowerCase());\n      case 'endsWith':\n        return String(value || '').toLowerCase().endsWith(String(filterValue || '').toLowerCase());\n      case 'in':\n        if (!Array.isArray(filterValue)) return false;\n        return filterValue.some(v => this.compareValues(value, v) === 0);\n      case 'notIn':\n        if (!Array.isArray(filterValue)) return true;\n        return !filterValue.some(v => this.compareValues(value, v) === 0);\n      default:\n        return true;\n    }\n  }\n\n  private static compareValues(a: DataValue, b: DataValue): number {\n    if (a === null || a === undefined) {\n      if (b === null || b === undefined) return 0;\n      return -1;\n    }\n    if (b === null || b === undefined) return 1;\n\n    if (a instanceof Date && b instanceof Date) {\n      return a.getTime() - b.getTime();\n    }\n\n    if (typeof a === 'number' && typeof b === 'number') {\n      return a - b;\n    }\n\n    const aStr = String(a).toLowerCase();\n    const bStr = String(b).toLowerCase();\n    \n    if (aStr < bStr) return -1;\n    if (aStr > bStr) return 1;\n    return 0;\n  }\n\n  static getUniqueValues(data: DataRow[], field: string): DataValue[] {\n    const values = new Set<DataValue>();\n    data.forEach(row => {\n      const value = row[field];\n      if (value !== null && value !== undefined) {\n        values.add(value);\n      }\n    });\n    return Array.from(values).sort((a, b) => this.compareValues(a, b));\n  }\n\n  static getFieldStatistics(data: DataRow[], field: string): {\n    count: number;\n    nullCount: number;\n    uniqueCount: number;\n    min?: DataValue;\n    max?: DataValue;\n    average?: number;\n  } {\n    const values = data.map(row => row[field]).filter(v => v !== null && v !== undefined);\n    const nullCount = data.length - values.length;\n    const uniqueValues = new Set(values);\n\n    const stats = {\n      count: values.length,\n      nullCount,\n      uniqueCount: uniqueValues.size,\n      min: undefined as DataValue,\n      max: undefined as DataValue,\n      average: undefined as number | undefined\n    };\n\n    if (values.length > 0) {\n      const sortedValues = [...values].sort((a, b) => this.compareValues(a, b));\n      stats.min = sortedValues[0];\n      stats.max = sortedValues[sortedValues.length - 1];\n\n      // Calculate average for numeric values\n      const numericValues = values.map(v => {\n        if (typeof v === 'number') return v;\n        if (typeof v === 'string') {\n          const parsed = parseFloat(v);\n          return isNaN(parsed) ? null : parsed;\n        }\n        return null;\n      }).filter(v => v !== null) as number[];\n\n      if (numericValues.length > 0) {\n        stats.average = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;\n      }\n    }\n\n    return stats;\n  }\n}","import { DataRow, DataValue, FieldInfo } from './types/data.types';\n\nexport class DataTransformer {\n  static normalizeData(data: DataRow[], schema: FieldInfo[]): DataRow[] {\n    return data.map(row => {\n      const normalizedRow: DataRow = {};\n      \n      schema.forEach(field => {\n        const value = row[field.name];\n        normalizedRow[field.name] = this.normalizeValue(value, field);\n      });\n\n      return normalizedRow;\n    });\n  }\n\n  static transformField(data: DataRow[], fieldName: string, transformer: (value: DataValue) => DataValue): DataRow[] {\n    return data.map(row => ({\n      ...row,\n      [fieldName]: transformer(row[fieldName])\n    }));\n  }\n\n  static addCalculatedField(\n    data: DataRow[], \n    fieldName: string, \n    calculator: (row: DataRow) => DataValue\n  ): DataRow[] {\n    return data.map(row => ({\n      ...row,\n      [fieldName]: calculator(row)\n    }));\n  }\n\n  static renameField(data: DataRow[], oldName: string, newName: string): DataRow[] {\n    return data.map(row => {\n      const newRow = { ...row };\n      if (oldName in newRow) {\n        newRow[newName] = newRow[oldName];\n        delete newRow[oldName];\n      }\n      return newRow;\n    });\n  }\n\n  static removeFields(data: DataRow[], fieldsToRemove: string[]): DataRow[] {\n    return data.map(row => {\n      const newRow = { ...row };\n      fieldsToRemove.forEach(field => {\n        delete newRow[field];\n      });\n      return newRow;\n    });\n  }\n\n  static selectFields(data: DataRow[], fieldsToKeep: string[]): DataRow[] {\n    return data.map(row => {\n      const newRow: DataRow = {};\n      fieldsToKeep.forEach(field => {\n        if (field in row) {\n          newRow[field] = row[field];\n        }\n      });\n      return newRow;\n    });\n  }\n\n  static fillMissingValues(data: DataRow[], field: string, fillValue: DataValue | ((row: DataRow) => DataValue)): DataRow[] {\n    return data.map(row => {\n      const value = row[field];\n      if (value === null || value === undefined || value === '') {\n        const newValue = typeof fillValue === 'function' ? fillValue(row) : fillValue;\n        return { ...row, [field]: newValue };\n      }\n      return row;\n    });\n  }\n\n  static removeDuplicates(data: DataRow[], keyFields?: string[]): DataRow[] {\n    const seen = new Set<string>();\n    const fields = keyFields || Object.keys(data[0] || {});\n\n    return data.filter(row => {\n      const key = fields.map(field => String(row[field] ?? '')).join('|');\n      if (seen.has(key)) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n  }\n\n  static groupAndTransform(\n    data: DataRow[], \n    groupByFields: string[], \n    transforms: { [key: string]: (group: DataRow[]) => DataValue }\n  ): DataRow[] {\n    const groups = new Map<string, DataRow[]>();\n\n    // Group the data\n    data.forEach(row => {\n      const key = groupByFields.map(field => String(row[field] ?? '')).join('|');\n      if (!groups.has(key)) {\n        groups.set(key, []);\n      }\n      groups.get(key)!.push(row);\n    });\n\n    // Transform each group\n    const result: DataRow[] = [];\n    groups.forEach((group, key) => {\n      const keyValues = key.split('|');\n      const transformedRow: DataRow = {};\n\n      // Add group key fields\n      groupByFields.forEach((field, index) => {\n        transformedRow[field] = this.parseValue(keyValues[index]);\n      });\n\n      // Add transformed fields\n      Object.keys(transforms).forEach(fieldName => {\n        transformedRow[fieldName] = transforms[fieldName](group);\n      });\n\n      result.push(transformedRow);\n    });\n\n    return result;\n  }\n\n  static pivotData(\n    data: DataRow[], \n    rowFields: string[], \n    columnField: string, \n    valueField: string,\n    aggregator: (values: DataValue[]) => DataValue = (values) => values.length\n  ): DataRow[] {\n    // Get all unique column values\n    const columnValues = new Set<DataValue>();\n    data.forEach(row => {\n      const colValue = row[columnField];\n      if (colValue !== null && colValue !== undefined) {\n        columnValues.add(colValue);\n      }\n    });\n\n    const sortedColumnValues = Array.from(columnValues).sort();\n\n    // Group by row fields\n    const rowGroups = new Map<string, DataRow[]>();\n    data.forEach(row => {\n      const key = rowFields.map(field => String(row[field] ?? '')).join('|');\n      if (!rowGroups.has(key)) {\n        rowGroups.set(key, []);\n      }\n      rowGroups.get(key)!.push(row);\n    });\n\n    // Create pivoted data\n    const result: DataRow[] = [];\n    rowGroups.forEach((group, key) => {\n      const keyValues = key.split('|');\n      const pivotedRow: DataRow = {};\n\n      // Add row key fields\n      rowFields.forEach((field, index) => {\n        pivotedRow[field] = this.parseValue(keyValues[index]);\n      });\n\n      // Add pivoted columns\n      sortedColumnValues.forEach(colValue => {\n        const colData = group.filter(row => row[columnField] === colValue);\n        const values = colData.map(row => row[valueField]);\n        const columnName = String(colValue);\n        pivotedRow[columnName] = values.length > 0 ? aggregator(values) : null;\n      });\n\n      result.push(pivotedRow);\n    });\n\n    return result;\n  }\n\n  private static normalizeValue(value: DataValue, field: FieldInfo): DataValue {\n    if (value === null || value === undefined) {\n      return field.nullable ? null : this.getDefaultValue(field.type);\n    }\n\n    switch (field.type) {\n      case 'number':\n        if (typeof value === 'number') return value;\n        if (typeof value === 'string') {\n          const parsed = parseFloat(value);\n          return isNaN(parsed) ? 0 : parsed;\n        }\n        return 0;\n\n      case 'boolean':\n        if (typeof value === 'boolean') return value;\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n          return lower === 'true' || lower === '1' || lower === 'yes';\n        }\n        if (typeof value === 'number') return value !== 0;\n        return false;\n\n      case 'date':\n        if (value instanceof Date) return value;\n        if (typeof value === 'string' || typeof value === 'number') {\n          const date = new Date(value);\n          return isNaN(date.getTime()) ? new Date() : date;\n        }\n        return new Date();\n\n      case 'string':\n      default:\n        return String(value);\n    }\n  }\n\n  private static getDefaultValue(type: FieldInfo['type']): DataValue {\n    switch (type) {\n      case 'number': return 0;\n      case 'boolean': return false;\n      case 'date': return new Date();\n      case 'string': return '';\n      default: return '';\n    }\n  }\n\n  private static parseValue(value: string): DataValue {\n    if (!value || value === 'null' || value === 'undefined') return null;\n    \n    // Try boolean\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n\n    // Try number\n    const numValue = parseFloat(value);\n    if (!isNaN(numValue) && isFinite(numValue)) {\n      return numValue;\n    }\n\n    // Try date\n    const dateValue = new Date(value);\n    if (!isNaN(dateValue.getTime())) {\n      return dateValue;\n    }\n\n    return value;\n  }\n}","import { DataRow, DataValue, FieldInfo, DataSchema, DataValidationResult } from './types/data.types';\n\nexport class DataValidator {\n  static validateDataset(data: DataRow[]): DataValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (!data || !Array.isArray(data)) {\n      errors.push('Data must be an array');\n      return {\n        isValid: false,\n        errors,\n        warnings,\n        schema: { fields: [], totalRows: 0, estimatedSize: 0 }\n      };\n    }\n\n    if (data.length === 0) {\n      warnings.push('Dataset is empty');\n    }\n\n    const schema = this.generateSchema(data);\n    const validation = this.validateAgainstSchema(data, schema);\n\n    return {\n      isValid: errors.length === 0 && validation.errors.length === 0,\n      errors: [...errors, ...validation.errors],\n      warnings: [...warnings, ...validation.warnings],\n      schema\n    };\n  }\n\n  private static generateSchema(data: DataRow[]): DataSchema {\n    if (data.length === 0) {\n      return { fields: [], totalRows: 0, estimatedSize: 0 };\n    }\n\n    const fields: FieldInfo[] = [];\n    const fieldMap = new Map<string, {\n      types: Set<string>;\n      nullable: boolean;\n      values: Set<DataValue>;\n      numericValues: number[];\n    }>();\n\n    data.forEach((row, index) => {\n      if (index >= 1000) return; // Sample first 1000 rows for schema generation\n\n      Object.keys(row).forEach(key => {\n        if (!fieldMap.has(key)) {\n          fieldMap.set(key, {\n            types: new Set(),\n            nullable: false,\n            values: new Set(),\n            numericValues: []\n          });\n        }\n\n        const fieldInfo = fieldMap.get(key)!;\n        const value = row[key];\n\n        if (value === null || value === undefined) {\n          fieldInfo.nullable = true;\n          fieldInfo.types.add('null');\n        } else {\n          fieldInfo.values.add(value);\n          const type = this.inferType(value);\n          fieldInfo.types.add(type);\n\n          if (type === 'number' && typeof value === 'number') {\n            fieldInfo.numericValues.push(value);\n          }\n        }\n      });\n    });\n\n    fieldMap.forEach((info, name) => {\n      const types = Array.from(info.types).filter(t => t !== 'null');\n      const primaryType = this.resolvePrimaryType(types);\n      \n      const field: FieldInfo = {\n        name,\n        type: primaryType,\n        nullable: info.nullable,\n        uniqueValues: info.values.size <= 100 ? Array.from(info.values) : undefined\n      };\n\n      if (primaryType === 'number' && info.numericValues.length > 0) {\n        field.min = Math.min(...info.numericValues);\n        field.max = Math.max(...info.numericValues);\n      }\n\n      fields.push(field);\n    });\n\n    const estimatedSize = this.estimateDataSize(data);\n\n    return {\n      fields,\n      totalRows: data.length,\n      estimatedSize\n    };\n  }\n\n  private static inferType(value: DataValue): 'string' | 'number' | 'boolean' | 'date' {\n    if (typeof value === 'number') return 'number';\n    if (typeof value === 'boolean') return 'boolean';\n    if (value instanceof Date) return 'date';\n    \n    if (typeof value === 'string') {\n      // Try to parse as date\n      const dateValue = new Date(value);\n      if (!isNaN(dateValue.getTime()) && this.isValidDateString(value)) {\n        return 'date';\n      }\n      \n      // Try to parse as number\n      const numValue = parseFloat(value);\n      if (!isNaN(numValue) && isFinite(numValue) && value.trim() === numValue.toString()) {\n        return 'number';\n      }\n    }\n\n    return 'string';\n  }\n\n  private static isValidDateString(str: string): boolean {\n    const datePatterns = [\n      /^\\d{4}-\\d{2}-\\d{2}$/,\n      /^\\d{2}\\/\\d{2}\\/\\d{4}$/,\n      /^\\d{2}-\\d{2}-\\d{4}$/,\n      /^\\d{4}\\/\\d{2}\\/\\d{2}$/\n    ];\n\n    return datePatterns.some(pattern => pattern.test(str));\n  }\n\n  private static resolvePrimaryType(types: string[]): 'string' | 'number' | 'boolean' | 'date' {\n    if (types.length === 0) return 'string';\n    if (types.length === 1) return types[0] as any;\n\n    const priority = ['date', 'number', 'boolean', 'string'];\n    for (const type of priority) {\n      if (types.includes(type)) {\n        return type as any;\n      }\n    }\n\n    return 'string';\n  }\n\n  private static validateAgainstSchema(data: DataRow[], schema: DataSchema): { errors: string[]; warnings: string[] } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    const fieldNames = new Set(schema.fields.map(f => f.name));\n\n    data.forEach((row, rowIndex) => {\n      Object.keys(row).forEach(key => {\n        if (!fieldNames.has(key)) {\n          warnings.push(`Row ${rowIndex + 1}: Unexpected field '${key}'`);\n        }\n      });\n\n      schema.fields.forEach(field => {\n        const value = row[field.name];\n        \n        if (!field.nullable && (value === null || value === undefined)) {\n          errors.push(`Row ${rowIndex + 1}: Field '${field.name}' cannot be null`);\n        }\n\n        if (value !== null && value !== undefined) {\n          const actualType = this.inferType(value);\n          if (actualType !== field.type) {\n            warnings.push(`Row ${rowIndex + 1}: Field '${field.name}' expected ${field.type}, got ${actualType}`);\n          }\n        }\n      });\n    });\n\n    return { errors, warnings };\n  }\n\n  private static estimateDataSize(data: DataRow[]): number {\n    if (data.length === 0) return 0;\n\n    const sampleSize = Math.min(100, data.length);\n    let totalSize = 0;\n\n    for (let i = 0; i < sampleSize; i++) {\n      totalSize += this.estimateRowSize(data[i]);\n    }\n\n    return Math.round((totalSize / sampleSize) * data.length);\n  }\n\n  private static estimateRowSize(row: DataRow): number {\n    return JSON.stringify(row).length * 2; // Rough estimate including object overhead\n  }\n}","import { \n  DataRow, \n  DataValue \n} from './types/data.types';\nimport {\n  PivotConfiguration, \n  PivotTable, \n  PivotCell, \n  PivotRow, \n  PivotColumn\n} from './types/pivot.types';\nimport { DataAggregator } from './aggregator';\n\nexport class PivotEngine {\n  private config: PivotConfiguration;\n  private data: DataRow[];\n\n  constructor(data: DataRow[], config: PivotConfiguration) {\n    this.data = data;\n    this.config = config;\n  }\n\n  generate(): PivotTable {\n    const startTime = performance.now();\n\n    const filteredData = this.applyFilters();\n    const { rowHeaders, columnHeaders } = this.buildHeaders(filteredData);\n    const dataMatrix = this.buildDataMatrix(filteredData, rowHeaders, columnHeaders);\n    \n    const pivotTable: PivotTable = {\n      rows: this.buildPivotRows(rowHeaders, dataMatrix),\n      columns: this.buildPivotColumns(columnHeaders),\n      data: dataMatrix,\n      metadata: {\n        totalRows: rowHeaders.length,\n        totalColumns: columnHeaders.length,\n        configuration: this.config,\n        generatedAt: new Date(),\n        processingTime: performance.now() - startTime\n      }\n    };\n\n    return pivotTable;\n  }\n\n  private applyFilters(): DataRow[] {\n    let filteredData = [...this.data];\n\n    if (this.config.filters && this.config.filters.length > 0) {\n      this.config.filters.forEach(filter => {\n        filteredData = filteredData.filter(row => {\n          const value = row[filter.name];\n          return value !== null && value !== undefined;\n        });\n      });\n    }\n\n    if (this.config.excludeEmptyRows) {\n      filteredData = filteredData.filter(row => {\n        return this.config.rows.some(field => {\n          const value = row[field.name];\n          return value !== null && value !== undefined && value !== '';\n        });\n      });\n    }\n\n    return filteredData;\n  }\n\n  private buildHeaders(data: DataRow[]): { rowHeaders: string[][], columnHeaders: string[][] } {\n    const rowHeadersSet = new Set<string>();\n    const columnHeadersSet = new Set<string>();\n\n    data.forEach(row => {\n      // Build row headers\n      const rowKey = this.config.rows.map(field => {\n        const value = row[field.name];\n        return this.formatValue(value, field.format);\n      }).join('|');\n      rowHeadersSet.add(rowKey);\n\n      // Build column headers\n      const columnKey = this.config.columns.map(field => {\n        const value = row[field.name];\n        return this.formatValue(value, field.format);\n      }).join('|');\n      columnHeadersSet.add(columnKey);\n    });\n\n    const rowHeaders = Array.from(rowHeadersSet).map(key => key.split('|'));\n    const columnHeaders = Array.from(columnHeadersSet).map(key => key.split('|'));\n\n    return { rowHeaders, columnHeaders };\n  }\n\n  private buildDataMatrix(data: DataRow[], rowHeaders: string[][], columnHeaders: string[][]): PivotCell[][] {\n    const matrix: PivotCell[][] = [];\n\n    rowHeaders.forEach((rowHeader, rowIndex) => {\n      const row: PivotCell[] = [];\n\n      columnHeaders.forEach((columnHeader, colIndex) => {\n        const cellData = this.getCellData(data, rowHeader, columnHeader);\n        const cell = this.createPivotCell(cellData, rowIndex, colIndex);\n        row.push(cell);\n      });\n\n      matrix.push(row);\n    });\n\n    // Add grand totals if enabled\n    if (this.config.showGrandTotals) {\n      this.addGrandTotals(matrix, data, rowHeaders, columnHeaders);\n    }\n\n    // Add subtotals if enabled\n    if (this.config.showRowSubtotals) {\n      this.addRowSubtotals(matrix, data, rowHeaders, columnHeaders);\n    }\n\n    if (this.config.showColumnSubtotals) {\n      this.addColumnSubtotals(matrix, data, rowHeaders, columnHeaders);\n    }\n\n    return matrix;\n  }\n\n  private getCellData(data: DataRow[], rowHeader: string[], columnHeader: string[]): DataRow[] {\n    return data.filter(row => {\n      const rowMatch = this.config.rows.every((field, index) => {\n        const value = this.formatValue(row[field.name], field.format);\n        return value === rowHeader[index];\n      });\n\n      const columnMatch = this.config.columns.every((field, index) => {\n        const value = this.formatValue(row[field.name], field.format);\n        return value === columnHeader[index];\n      });\n\n      return rowMatch && columnMatch;\n    });\n  }\n\n  private createPivotCell(data: DataRow[], row: number, column: number): PivotCell {\n    let value: DataValue = null;\n    let formattedValue = '';\n\n    if (this.config.values.length > 0) {\n      const valueField = this.config.values[0]; // For now, handle single value field\n      const aggregationType = valueField.aggregation || 'sum';\n      \n      value = DataAggregator.aggregate(data, valueField.name, aggregationType);\n      formattedValue = valueField.format \n        ? valueField.format(value)\n        : this.formatValue(value);\n    } else {\n      value = data.length;\n      formattedValue = String(value);\n    }\n\n    return {\n      value,\n      formattedValue,\n      rawValue: value,\n      aggregationType: this.config.values[0]?.aggregation || 'count',\n      contributingRows: data,\n      coordinates: { row, column },\n      metadata: {\n        isGrandTotal: false,\n        isSubtotal: false,\n        isHeader: false,\n        level: 0,\n        parentPath: []\n      }\n    };\n  }\n\n  private buildPivotRows(headers: string[][], dataMatrix: PivotCell[][]): PivotRow[] {\n    return headers.map((header, index) => ({\n      cells: dataMatrix[index] || [],\n      level: 0,\n      isExpanded: true,\n      hasChildren: false,\n      parentPath: header.slice(0, -1),\n      key: header.join('|')\n    }));\n  }\n\n  private buildPivotColumns(headers: string[][]): PivotColumn[] {\n    return headers.map((header) => ({\n      name: header[header.length - 1],\n      displayName: header[header.length - 1],\n      width: 120,\n      level: 0,\n      parentPath: header.slice(0, -1),\n      key: header.join('|'),\n      isExpanded: true,\n      hasChildren: false\n    }));\n  }\n\n  private addGrandTotals(matrix: PivotCell[][], _data: DataRow[], _rowHeaders: string[][], columnHeaders: string[][]): void {\n    // Add grand total row\n    const grandTotalRow: PivotCell[] = [];\n    columnHeaders.forEach((_, colIndex) => {\n      const allCellData = matrix.map(row => row[colIndex]).flatMap(cell => cell.contributingRows || []);\n      const cell = this.createPivotCell(allCellData, matrix.length, colIndex);\n      cell.metadata!.isGrandTotal = true;\n      grandTotalRow.push(cell);\n    });\n    matrix.push(grandTotalRow);\n\n    // Add grand total column\n    matrix.forEach((row, rowIndex) => {\n      const allCellData = row.flatMap(cell => cell.contributingRows || []);\n      const cell = this.createPivotCell(allCellData, rowIndex, row.length);\n      cell.metadata!.isGrandTotal = true;\n      row.push(cell);\n    });\n  }\n\n  private addRowSubtotals(_matrix: PivotCell[][], _data: DataRow[], _rowHeaders: string[][], _columnHeaders: string[][]): void {\n    // Implementation for row subtotals\n    // This would need to analyze the row hierarchy and insert subtotal rows\n  }\n\n  private addColumnSubtotals(_matrix: PivotCell[][], _data: DataRow[], _rowHeaders: string[][], _columnHeaders: string[][]): void {\n    // Implementation for column subtotals\n    // This would need to analyze the column hierarchy and insert subtotal columns\n  }\n\n  private formatValue(value: DataValue, formatter?: (value: DataValue) => string): string {\n    if (formatter) {\n      return formatter(value);\n    }\n\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    if (typeof value === 'number') {\n      return value.toLocaleString();\n    }\n\n    if (value instanceof Date) {\n      return value.toLocaleDateString();\n    }\n\n    return String(value);\n  }\n\n  updateConfiguration(config: Partial<PivotConfiguration>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  updateData(data: DataRow[]): void {\n    this.data = data;\n  }\n}"]}